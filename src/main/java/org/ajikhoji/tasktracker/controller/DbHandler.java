package org.ajikhoji.tasktracker.controller;

import java.io.File;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashSet;

import org.ajikhoji.tasktracker.model.Status;
import org.ajikhoji.tasktracker.model.Task;
import org.ajikhoji.tasktracker.view.TaskViewerPage;

public class DbHandler {

    /*
     *   NOTE : Replace the string values below. Use a sample database for testing purpose.
     *   WARNING : Do not hardcode sensitive information here. Find alternatives to ensure security.
     */
    private final static String STR_DATABASE_NAME = "Database Name";
    private final static String STR_USER_NAME = "User Name";
    private final static String STR_PASSWORD = "Password";
    private final static String STR_DATABASE_PATH = "Path to Database";

    private Connection con = null;

    public DbHandler() {
        if(STR_DATABASE_NAME == null || STR_USER_NAME == null || STR_PASSWORD == null || STR_DATABASE_PATH.equals(System.getenv("LOCALAPPDATA"))) {
            System.err.println("Unable to load Data as a problem persists on Database configuration");
            System.exit(-1);
            return;
        }
        if(!new File(STR_DATABASE_PATH + "\\TaskTracker.log").exists()) {
            this.configureDatabase();
        }
        this.init();
    }

    private void configureDatabase() {
        //open the database and create a new USER with password GRANTING ALL access.
        try {
            Class.forName("org.hsqldb.jdbc.JDBCDriver");
            final String jdbcUrl = "jdbc:hsqldb:file:" + DbHandler.STR_DATABASE_PATH + "\\" + DbHandler.STR_DATABASE_NAME + ";create=true";
            this.con = DriverManager.getConnection(jdbcUrl, "SA", "");

            assert this.con != null;

            final Statement stmt = this.con.createStatement();
            stmt.executeUpdate("CREATE USER " + DbHandler.STR_USER_NAME + " PASSWORD '" + DbHandler.STR_PASSWORD + "' ADMIN;");
            stmt.executeUpdate("GRANT DBA TO " + DbHandler.STR_USER_NAME + ";");

            this.con.commit();
            this.con.close();
            this.con = null;
        } catch (final ClassNotFoundException | SQLException e) {
            System.err.println(DbHandler.class.getCanonicalName() + " - configureDatabase(): Error in opening database.");
        }

        final String jdbcUrl = "jdbc:hsqldb:file:" + DbHandler.STR_DATABASE_PATH + "\\" + DbHandler.STR_DATABASE_NAME + ";ifexists=true";
        //deleting default user (SA) to restrict access through SA.
        try (final Connection conn = DriverManager.getConnection(jdbcUrl, DbHandler.STR_USER_NAME, DbHandler.STR_PASSWORD);
             final Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("DROP USER SA;");
            conn.commit();
            conn.close();
        } catch (SQLException e) {
            System.err.println(DbHandler.class.getCanonicalName() + " - configureDatabase(): Error in opening database.");
        }
    }

    private boolean executeQuery(final String query) {
        try {
            final Statement st = this.con.createStatement();
            st.execute(query);
        } catch (final Exception e) {
            e.printStackTrace(System.err);
            return false;
        }
        return true;
    }

    private void init() {
        //open the database
        try {
            Class.forName("org.hsqldb.jdbc.JDBCDriver");
            final String jdbcUrl = "jdbc:hsqldb:file:" + DbHandler.STR_DATABASE_PATH + "\\" + DbHandler.STR_DATABASE_NAME + ";ifexists=true";
            this.con = DriverManager.getConnection(jdbcUrl, DbHandler.STR_USER_NAME, DbHandler.STR_PASSWORD);
        } catch (final ClassNotFoundException | SQLException e) {
            System.err.println(DbHandler.class.getCanonicalName() + " - Constructor: Error in opening database.");
        }

        final String queryCreateTaskTable =
            """
                CREATE TABLE IF NOT EXISTS Task (
                    tid INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    title VARCHAR(50) NOT NULL,
                    status VARCHAR(20) NOT NULL,
                    description VARCHAR(400) NOT NULL,
                    remarks VARCHAR(400) NOT NULL,
                    deadline TIMESTAMP,
                    added TIMESTAMP,
                    modified TIMESTAMP
                );
            """;
        this.executeQuery(queryCreateTaskTable);

        final String queryCreateTagTable =
            """
                CREATE TABLE IF NOT EXISTS Tag (
                    tid INTEGER,
                    name VARCHAR(20),
                    PRIMARY KEY (tid, name),
                    FOREIGN KEY (tid) REFERENCES Task(tid) ON DELETE CASCADE
                );
            """;
        this.executeQuery(queryCreateTagTable);
    }

    public int addNewTask(final Task t) {
        int id;

        try {
            final String queryInsertNewRecord =
                    """
                        INSERT INTO Task (tid, title, status, description, remarks, deadline, added, modified)
                        VALUES (DEFAULT, ?, ?, ?, ?, ?, ?, ?);
                    """;
            final PreparedStatement psInsert = this.con.prepareStatement(queryInsertNewRecord, Statement.RETURN_GENERATED_KEYS);
            psInsert.setString(1, t.getTitle());
            psInsert.setString(2, t.getStatus().name());
            psInsert.setString(3, t.getDescription());
            psInsert.setString(4, t.getRemarks());
            psInsert.setString(5, t.getDeadlineDateTime().toString().replace("T"," "));
            psInsert.setString(6, t.getAddedDateTime().toString().replace("T"," "));
            if (t.getModifiedDateTime() == null) {
                psInsert.setNull(7, java.sql.Types.TIMESTAMP);
            } else {
                psInsert.setTimestamp(7, Timestamp.valueOf(t.getModifiedDateTime()));
            }

            psInsert.executeUpdate();
            ResultSet rs = psInsert.getGeneratedKeys();
            if(rs.next()) {
                id = rs.getInt(1);
            } else {
                return Task.NOT_ASSIGNED;
            }

            if(!t.getTags().isEmpty()) {
                final String queryInsertTags = "INSERT INTO Tag (tid, name) VALUES (?, ?);";
                final PreparedStatement psInsertTags = this.con.prepareStatement(queryInsertTags);

                for(final String tag : t.getTags()) {
                    psInsertTags.setInt(1, id);
                    psInsertTags.setString(2, tag);
                    psInsertTags.addBatch();
                }

                psInsertTags.executeBatch();
            }
        } catch (final Exception e) {
            e.printStackTrace(System.err);
            return Task.NOT_ASSIGNED;
        }

        return id;
    }

    public boolean deleteTask(final Task t) {
        assert t.getId() != Task.NOT_ASSIGNED;
        final String queryDelete = String.format("DELETE FROM Task WHERE tid = %d;", t.getId());

        return this.executeQuery(queryDelete);
    }

    public boolean updateTask(final Task tOld, final Task tNew) {
        StringBuilder sbUpdate = new StringBuilder("UPDATE Task SET");
        if(!tOld.getTitle().equals(tNew.getTitle())) {
            sbUpdate.append(String.format(" title = '%s',", tNew.getTitle()));
        }
        if(!tOld.getDescription().equals(tNew.getDescription())) {
            sbUpdate.append(String.format(" description = '%s',", tNew.getDescription()));
        }
        if(!tOld.getRemarks().equals(tNew.getRemarks())) {
            sbUpdate.append(String.format(" remarks = '%s',", tNew.getRemarks()));
        }
        if(!tOld.getStatus().equals(tNew.getStatus())) {
            sbUpdate.append(String.format(" status = '%s',", tNew.getStatus()));
        }
        if(!tOld.getDeadlineDateTime().equals(tNew.getDeadlineDateTime())) {
            sbUpdate.append(String.format(" deadline = '%s',", tNew.getDeadlineDateTime().toString().replace("T"," ")));
        }

        if(!sbUpdate.toString().equals("UPDATE Task SET")) {//run query only if there is a change
            final LocalDateTime oldModified = tOld.getModifiedDateTime();
            final LocalDateTime newModified = tNew.getModifiedDateTime();
            if((oldModified == null && newModified != null) || (oldModified != null && !oldModified.equals(newModified))) {
                sbUpdate.append(String.format(" modified = '%s',", newModified.toString().replace("T"," ")));
            }

            sbUpdate.deleteCharAt(sbUpdate.length() - 1);
            sbUpdate.append(String.format(" WHERE tid = %d;", tNew.getId()));

            if(!this.executeQuery(sbUpdate.toString())) {
                return false;
            }
        }

        final HashSet<String> removed = new HashSet<>();
        final HashSet<String> added = new HashSet<>();

        for(final String oldTag : tOld.getTags()) {
            if(!tNew.getTags().contains(oldTag)) {
                removed.add(oldTag);
            }
        }

        for(final String newTag : tNew.getTags()) {
            if(!tOld.getTags().contains(newTag)) {
                added.add(newTag);
            }
        }

        if(!removed.isEmpty()) {
            try {
                sbUpdate = new StringBuilder("DELETE FROM Tag WHERE tid = ? AND name IN (");
                for(int i = 0; i < removed.size(); ++i) {
                    sbUpdate.append("?,");
                }
                sbUpdate.setCharAt(sbUpdate.length() - 1, ')');
                sbUpdate.append(";");

                final PreparedStatement psInsertTags = this.con.prepareStatement(sbUpdate.toString());

                psInsertTags.setInt(1, tNew.getId());
                int counter = 1;
                for (final String tag : added) {
                    psInsertTags.setString(++counter, tag);
                }

                psInsertTags.executeUpdate();
            } catch (final Exception e) {
                e.printStackTrace(System.err);
                return false;
            }
        }

        if(!added.isEmpty()) {
            try {
                final String queryInsertTags = "INSERT INTO Tag (tid, name) VALUES (?, ?);";
                final PreparedStatement psInsertTags = this.con.prepareStatement(queryInsertTags);

                for (final String tag : added) {
                    psInsertTags.setInt(1, tNew.getId());
                    psInsertTags.setString(2, tag);
                    psInsertTags.addBatch();
                }

                psInsertTags.executeBatch();
            } catch (final Exception e) {
                e.printStackTrace(System.err);
                return false;
            }
        }

        return true;
    }

    public void load() {
        final String queryRetrieveAllTasksInfo =
            """
                SELECT
                    t.tid,
                    t.title,
                    t.description,
                    t.remarks,
                    t.deadline,
                    COALESCE(GROUP_CONCAT(tag.name), '') AS tags,
                    t.status,
                    t.added,
                    t.modified
                FROM
                    Task t
                LEFT JOIN
                    Tag tag ON t.tid = tag.tid
                GROUP BY
                    t.tid, t.title, t.desc, t.rem, t.deadline, t.status, t.added, t.modified;
            """;

        try {
            final Statement st = this.con.createStatement();
            final ResultSet rs = st.executeQuery(queryRetrieveAllTasksInfo);

            while(rs.next()) {
                final Task t = new Task();
                t.setId(rs.getInt("tid"));
                t.setStatus(Status.valueOf(rs.getString("status")));

                t.setTitle(rs.getString("title"));
                t.setDescription(rs.getString("description"));
                t.setRemarks(rs.getString("remarks"));

                t.setDeadlineDateTime(LocalDateTime.parse(rs.getString("deadline").substring(0, 19), DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
                t.setAddedDateTime(LocalDateTime.parse(rs.getString("added").substring(0, 19), DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
                final String modifiedDate = rs.getString("modified");
                if(modifiedDate != null) {
                    t.setModifiedDateTime(LocalDateTime.parse(modifiedDate.substring(0, 19), DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
                }

                final String tagList = rs.getString("tags");
                if(!tagList.isEmpty()) {
                    for(final String tag : tagList.split(",")) {
                        t.addTag(tag);
                        TaskManager.incrementTagCount(tag);
                    }
                }

                TaskViewerPage.getInstance().add(t);
            }
        } catch (final Exception e) {
            e.printStackTrace(System.err);
        }
    }

    public void close() {
        try {
            this.con.commit();
            this.con.close();
        } catch (final Exception e) {
            System.err.println("Failed to save changes");
        }
    }

}
